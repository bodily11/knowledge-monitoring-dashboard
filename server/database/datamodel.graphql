# Users
type Instructor {
    id: ID! @unique
    email: String! @unique
    password: String!
    createdAt: DateTime!
    courses: [Course!]!
}

type Student {
    id: ID! @unique
    # This is a simplistic approach, where each student has to be created and logged in via LTI.
    ltiUserId: String! @unique
    # If one student is in multiple courses that each have a different LTI user ID, they will have multiple 'accounts' on wadayano, so email isn't necessarily unique
    email: String!
    name: String!
    quizAttempts: [QuizAttempt!]!
}

# Course data hierarchy
type Course {
    id: ID! @unique
    title: String!
    createdAt: DateTime!
    quizzes: [Quiz!]!
    concepts: [Concept!]!
}

type Concept {
    id: ID! @unique
    title: String!
}

type Quiz {
    id: ID! @unique
    createdAt: DateTime!
    questions: [Question!]!
    concepts:[Concept!]!
    course: Course!
    title: String!
}

type Question {
    id: ID! @unique
    options: [Option!]!
    prompt: String!
    concept: Concept
}

type Option {
    id: ID! @unique
    question: Question!
    isCorrect: Boolean
    text: String!
}

# Student quiz attempt data
type QuizAttempt {
    id: ID! @unique
    student: Student!
    quiz: Quiz!
    createdAt: DateTime!
    ltiSessionInfo: Json
    completed: DateTime
    questionAttempts: [QuestionAttempt!]!
    score: Float # (correct/total). No score indicates the attempt was started, but not yet finished
    conceptConfidences: [ConceptConfidence!]!
    totalConfidenceError: Float # Sum of forEach(attempt =>  abs(isConfident - isCorrect)). 0 == perfect estimation accuracy
    totalConfidenceBias: Float # Sum of forEach(attempt => isConfident - isCorrect). Positive == overestimated; 0 == counterbalanced or no bias
}

type QuestionAttempt {
    id: ID! @unique
    createdAt: DateTime!
    question: Question!
    option: Option! @relation(name: "SelectedAnswerAttemptRelation")
    isCorrect: Boolean! # Yes, this is duplicating isCorrect from Option, but student should be able to review their past attempts without us always having to expose isCorrect on Options
    correctOption: Option! @relation(name: "CorrectAnswerAttemptRelation") # See note for isCorrect
    isConfident: Boolean!
}

type ConceptConfidence {
    id: ID! @unique
    concept: Concept
    confidence: Int
    confidenceError: Float # Same as above, but filtered to a single concept. Not required, since it will be added once the quiz is done
    confidenceBias: Float # Ditto
}
